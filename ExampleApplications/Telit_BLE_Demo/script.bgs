# ==============================================================================================================
#
# BGScript Demo     : EVK2 WAB cable replacement demo.
#
# Description       : Communicates with a Telit module over UART through the
#                     EVK2 WAB. Waits for the telit to connect to the internet and then allows the
#                     user to enter a number between 1 and 10 before sending a message back to the
#                     user by SMS, demonstrating the use of the BLE and Telit modules on the WAB. 
#
# Author            : Rob Clucas 
#
# Wiki Page			: Step by step explanation of the code can be 
#                     be found at :
#
#                     https://github.com/X-Intellect/EVK2-WAB/wiki/Telit-----BLE-Communication-Example
#
#
#                     Additionally, for other examples for the 
#                     EVK2 WAB board, see the Wiki page at:
#
#                     https://github.com/X-Intellect/EVK2-WAB/wiki/EVK2-WAB-Example-Applications
#
#
#                     Or find the latest version of the source code at :
#
#                     https://github.com/X-Intellect/EVK2-WAB/tree/master/ExampleApplications/Telit_BLE_Demo
#
# ==============================================================================================================
#                                                 CHANGELOG:
# ==============================================================================================================
#   
# 2015-05-20        : Initial release
#
# ==============================================================================================================

dim in(20)          # Endpoint data in buffer
dim in_len          # Endpoint data in buffer size
dim out(20)         # Endpoint data out buffer
dim out_len         # Endpoint data out buffer size
dim result          # Endpoint RX error code
dim at(2)			# AT command for Telit
dim ok(2)           # OK response from Telit
dim cgsn(6)         # Command to query the Telit for it's information
dim connected       # If a connection has been established with the Telit module
dim ser_num(20)     # The product serial number of the Telit module
dim ser_len         # Length of the serial number 

# ============================================================================================================== #
#                                            GENERAL PROCEDURES                                                  #
# ============================================================================================================== #

# Procedure to get the hardware and software number of the Telit module
procedure get_telit_info()
    # Enable the RX watermark so we can get the messages back
    call system_endpoint_set_watermarks( 5, 1, $ff )

    # Send a command to the Telit module to get  it's serial number
    call system_endpoint_tx( 5, 8, "AT#CGSN\r" )
    
    # Enable the RX watermark so we can get the messages back
    call system_endpoint_set_watermarks( 5, 1, $ff )

    # Save the serial number
    if  memcmp( in( 0 ), cgsn( 0 ), 6 ) then
        memcpy( ser_num( 0 ), in( 5 ), in_len - 5 )

        # Set ser_num length and reset in_len
        ser_len = in_len - 5
        in_len = 0

        # Write the produt number to the gatt database
        call attributes_write( xgatt_data, 0, ser_len, ser_num( 0 : ser_len ) )
    end if 
end 

# Procedure to test if the Telit module has an internet connection 
procedure test_telit_internet()

    # Disable RX watermark
    call system_endpoint_set_watermarks( 5, 1 , $ff )

    # Send the internet test command
    call system_endpoint_tx( 5, 9, "AT+CREG?\r" )
    
    # Enable RX watermarks so that the responses can be retrieved
    call system_endpoint_set_watermarks( 5, 1, $ff ) 

end 

# Procedure to get and save the user's cellphone number
procedure get_cell_number()
end 

# ============================================================================================================== #
#                                              MAIN FUNCTIONALITY                                                #
# ============================================================================================================== #

# Event boot listener - Executed when the device is booted
event system_boot( major, minor, patch, build, ll_version, protocol, hw )
    # Disable all watermarks
    call system_endpoint_set_watermarks( 5, 0, 0 )

	# Set the device to advertise so that it can be found by the phone/tablet
	call gap_set_mode( gap_general_discoverable, gap_undirected_connectable )

	# Set the at buffer to hold the value 'AT'
	at( 0 : 2 ) = "AT"

    # Set the ok buffer to hold the value to 'OK'
    ok( 0 : 2 ) = "OK"

	# Set a once off timer for +-3 seconds time which will be used to setup 
	# the communication between the BLE module and the Telit module
	# 
	# Arg1 : The number of oscillations before the timer interrupts. The
	#        frequency of  oscillation of the clock is +1 32700Hz so we have set
	#        a timer for approximately 3 seconds from boot
	# Arg2 : The handle of the timer
	# Arg3 : Repeated. We set this to 0 since the timer must continually
	#        interrupt, in case there was no connection on the previous attempts
    call hardware_set_soft_timer( 96768, 1, 0 )

	# Set the connected variable to false
	connected = 0
end

# Executed when the timer interrupt is triggered
event hardware_soft_timer( handle )
	# Check that the timer with handle = 1 caused the interrupt
	if handle = 1 then 
        # If a connection has been established on the previous interrupt
        if connected = 1 then
            # Enable RX watermarks 
            call system_endpoint_set_watermarks( 5, 1, $ff )
            
            # Set the connected state to globally connected so that the 
            # rest of the application can function normally
            connected = 2 
        end if 

		# If there has been no connection established then
		# we will send the 'AT' command to the telit to 
		# check if it is on
		if connected = 0
		    # Disable the RX watermarks
		    call system_endpoint_set_watermarks( 5, 0, $ff )

		    # Now write "AT\r" to the UART connection
		    call system_endpoint_tx( 5, 3, "AT\r" )

		    # Enable RX watermark so that we can get the response
		    call system_endpoint_set_watermarks( 5, 2, $ff )

            # Wait for a response
		    while in_len = 0 
            end while

		    # The Telit should have responded, check that it responded with OK
		    if memcmp( in( 0 ), ok( 0 ), 2 ) then 

                # Disable the RX watermark
                call system_endpoint_set_watermarks( 5, 0, $ff )

                # Output the results to the Telit 
		        call attributes_write( xgatt_data, 0, 15 , "UART CONNECTED\n" )

                # Get the Telit's information 
                #call get_telit_info()
                call test_telit_internet()

                # Set that the connection is established
                connected = 1 
            end if
            # The Telit may be echoing commands, so check for that
		    if memcmp( in( 0 ), at( 0 ), 2 ) then
                # Check if the last two chars were okay
                if memcmp( in( 5 ), ok( 0 ), 2 ) then

                    # Disable RX watermarks 
                    call system_endpoint_set_watermarks( 5, 9, $ff )

                    # Output the results to the Telit 
		            call attributes_write( xgatt_data, 0, 15 , "UART CONNECTED\n" )

                    # Get the Telit model information 
                    #call get_telit_info()
                    #call test_telit_internet()

                    # Send a message to the Telit telling it to not echo
                    call system_endpoint_tx( 5, 5, "ATE1\r" )

                    #call system_endpoint_set_watermarks( 5, 9, $ff )
                    call system_endpoint_tx( 5, 10, "AT+CREG?\r" )
                    call system_endpoint_set_watermarks( 5, 1, $ff )

                    # Set that a connection has been established
                    connected = 2
                else 
                    # No connection
                    connected = 0
                end if
            else
                if connected = 0 then  
                    # Send a message saying that there is no connection so far
                    call attributes_write( xgatt_data, 0, 20, "QUERYING TELIT ...\n" )
                end if
            end if
		end if
    end if 
end

# Executed when the connection is lost 
event connection_disconnected( connection, reason )
	# Disable all watermarks
	call system_endpoint_set_watermarks( 5, 0, 0 )

	# Set the device to advertise so that a connection can be re-established
	call gap_set_mode( gap_general_discoverable, gap_undirected_connectable )
end 

# Executed when there is incoming data from a bluetooth connection
event attributes_value( connection, reason, handle, offset, value_len, value_data )
	# Check that the data was written to xgatt
	if handle = xgatt_data then 
		# Copy the data from GATT database to out variable
		out( 0 : value_len ) = value_data( 0 : value_len )
		
        out( value_len : value_len + 1 ) = "\r"

		# Set the length of out to the received number of bytes from value 
		out_len = value_len  + 1

		# Enable TX watermarks so that the data can be sent over UART
		call system_endpoint_set_watermarks( 5, $ff, out_len )
	end if 
end

# Executed when data must be sent over UART
event system_endpoint_watermark_tx( endpoint, size )
	# Check that the endpoint is for UART
	if endpoint = 5
		# Disable the TX watermark
		#call system_endpoint_set_watermarks( 5, $ff, 0 )

		# Write the data from the out variable to UART
		call system_endpoint_tx( 5, out_len, out( 0 : out_len ) )

		# Write a response to the device on the other side 
		# of the bluetooth connection (iOS or android device)
		if connected = 2 
		    call attributes_user_write_response( 0, 0 )
        end if 

		# Reset the length of the output data to 0
		out_len = 0
	end if
end

# Executed when the device on the other side of the bluetooth connection 
# changes its Client Characteristic Configuration value changes (the 
# device on the other side should do this by itself)
event attributes_status( handle, flags )
	if handle = xgatt_data then
		if flags & 2 then
            if connected = 2 then
			    # If the indicators are enabled :
			    # Set the RX watermark to trigger when 1 byte is received
			    call system_endpoint_set_watermarks( 5, 1, $ff )
            end if
		else 
			# If the indicators are disabled :
			# Disable the RX watermarks
			call system_endpoint_set_watermarks( 5, 0, $ff )
		end if
	end if
end

# Executed when there is data available from UART
event system_endpoint_watermark_rx( endpoint, size )
    # If the endpoint is the UART endpoint
	if endpoint = 5
		# Set the length of the input data
        in_len = size

		# Since we can only hvae 20 bytes of data, check this
		if in_len > 20 then 
            # If too much data, set the length to the max amount
            in_len = 20
		end if 

        # Disable RX watermark
        call system_endpoint_set_watermarks( 5, 0, $ff )

		# Get the data from the UART
		call system_endpoint_rx( 5, in_len )( result, in_len, in( 0 : in_len ) )

		# Write the result to the device on the other side of the bluetooth
		# connection, if there is an established connection with the telit
		if connected = 2 
		    call attributes_write( xgatt_data, 0, in_len, in( 0 : in_len ) )
        end if
	end if
end

# Executed when the remote device acknowledges data reception
event attclient_indicated( connection, attrhandle )
	if attrhandle = xgatt_data then 
		# Enable the RX watermark for 1 byte so that 
		# more data can be received over UART
		call system_endpoint_set_watermarks( 5, 1, $ff )
		
		# Reset the amount of data that was received from UART
		in_len = 0
	end if
end
 

