# ==============================================================================================================
#
# BGScript Demo     : EVK2 WAB cable replacement demo.
#
# Description       : Communicates with a Telit module over UART through the
#                     EVK2 WAB. Waits for the telit to connect to the internet and then allows the
#                     user to enter a number between 1 and 10 before sending a message back to the
#                     user by SMS, demonstrating the use of the BLE and Telit modules on the WAB. 
#
# Author            : Rob Clucas 
#
# Wiki Page			: Step by step explanation of the code can be 
#                     be found at :
#
#                     https://github.com/X-Intellect/EVK2-WAB/wiki/Telit-----BLE-Communication-Example
#
#
#                     Additionally, for other examples for the 
#                     EVK2 WAB board, see the Wiki page at:
#
#                     https://github.com/X-Intellect/EVK2-WAB/wiki/EVK2-WAB-Example-Applications
#
#
#                     Or find the latest version of the source code at :
#
#                     https://github.com/X-Intellect/EVK2-WAB/tree/master/ExampleApplications/Telit_BLE_Demo
#
# ==============================================================================================================
#                                                 CHANGELOG:
# ==============================================================================================================
#   
# 2015-05-20        : Initial release
#
# ==============================================================================================================

dim in(20)          # Endpoint data in buffer
dim in_len          # Endpoint data in buffer size
dim out(20)         # Endpoint data out buffer
dim out_len         # Endpoint data out buffer size
dim result          # Endpoint RX error code
dim at(2)			# AT command for Telit
dim ok(2)           # OK response from Telit
dim connected       # If a connection has been established with the Telit module
dim attempts        # The number of times we have tried to contact the Telit module
dim sleep           # Counter used to simulate sleeping
const timer = 12768 # Counts for manual timer

# Event boot listener - Executed when the device is booted
event system_boot( major, minor, patch, build, ll_version, protocol, hw )
    # Disable all watermarks
    call system_endpoint_set_watermarks( 5, 0, 0 )

	# Set the device to advertise so that it can be found by the phone/tablet
	call gap_set_mode( gap_general_discoverable, gap_undirected_connectable )

	# Set the at buffer to hold the value 'AT'
	at( 0 : 2 ) = "AT"

    # Set the ok buffer value to 'OK'
    ok( 0 : 2 ) = "OK"

	# Set a once off timer for +-3 seconds time which will be used to setup 
	# the communication between the BLE module and the Telit module
	# 
	# Arg1 : The number of oscillations before the timer interrupts. The
	#        frequency of  oscillation of the clock is +1 32700Hz so we have set
	#        a timer for approximately 1 seconds from boot
	# Arg2 : The handle of the timer
	# Arg3 : Singleshot. We set this to 1 since the timer must only interrupt
	#        once.
    call hardware_set_soft_timer( 32768, 1, 1 )

	# Set the connected variable to false
	connected = 0
end

# Executed when the timer interrupt is triggered
event hardware_soft_timer( handle )
	# Check that the timer with handle = 1 caused the interrupt
	if handle = 1 then 
        # Create a temporary counter values
        attempts = 0        # For the number of times we query the Telit module
        sleep    = 0        # Counter for manual sleep
	
		# We will run a loop that will send the 'AT' command to the 
		# Telit module until we get an okay response or we exceed 10 attempts
		while  attempts < 100
			# Disable the RX watermarks
			call system_endpoint_set_watermarks( 5, 0, $ff )

            # Now write "AT\r" to the UART connection
			call system_endpoint_tx( 5, 3, "AT\r" )

			# Enable RX watermark so that we can get the response
			call system_endpoint_set_watermarks( 5, 1, $ff )

			# The Telit should have responded, check that it responded with OK
			if memcmp( in( 0 ), ok( 0 ), 2 ) then 
				# The Telit is on, set connected and set attempts to terminate
				# while loop
				connected = 1
                attempts  = 100

				# Note : By default the Telit module is set to echo commands
				#        back, so if we send something to it, it will come back,
				#        be read in by the uart rx, and sent to the app 
				call system_endpoint_tx( 5, 10, "SUCCESS\n" )
			else 
                # Increment the number of attempts and set to not connected
                connected = 0
            end if
            
            # Increment number of attempts
            attempts = attempts + 1
		end while
    end if 
end

# Executed when the connection is lost 
event connection_disconnected( connection, reason )
	# Disable all watermarks
	call system_endpoint_set_watermarks( 5, 0, 0 )

	# Set the device to advertise so that a connection can be re-established
	call gap_set_mode( gap_general_discoverable, gap_undirected_connectable )
end 

# Executed when there is incoming data from a bluetooth connection
event attributes_value( connection, reason, handle, offset, value_len, value_data )
	# Check that the data was written to xgatt
	if handle = xgatt_data then 
		# Copy the data from GATT database to out variable
		out( 0 : value_len ) = value_data( 0 : value_len )
		
		# Set the length of out to the received number of bytes from value 
		out_len = value_len 

		# Check if the user sent 'AT'
		if memcmp( out( 0 ), at( 0 ), 2 ) then 
			# Set the result to be 'AT\r' as this is what the telit wants
			# but the BLE Cable replacement app can't do return carriage
			out( 0 : 3 ) = "AT\r"

			# Set the length of the output buffer to be 3
			out_len = 3
		end if

		# Enable TX watermarks so that the data can be sent over UART
		call system_endpoint_set_watermarks( 5, $ff, out_len )
	end if 
end

# Executed when data must be sent over UART
event system_endpoint_watermark_tx( endpoint, size )
	# Check that the endpoint is for UART
	if endpoint = 5
		# Disable the TX watermark
		#call system_endpoint_set_watermarks( 5, $ff, 0 )

		# Write the data from the out variable to UART
		call system_endpoint_tx( 5, out_len, out( 0 : out_len ) )

		# Write a response to the device on the other side 
		# of the bluetooth connection (iOS or android device)
		if connected = 1 
		    call attributes_user_write_response( 0, 0 )
        end if 

		# Reset the length of the output data to 0
		out_len = 0
	end if
end

# Executed when the device on the other side of the bluetooth connection 
# changes its Client Characteristic Configuration value changes (the 
# device on the other side should do this by itself)
event attributes_status( handle, flags )
	if handle = xgatt_data then
		if flags & 2 then 
			# If the indicators are enabled :
			# Set the RX watermark to trigger when 1 byte is received
			call system_endpoint_set_watermarks( 5, 1, $ff )
		else 
			# If the indicators are disabled :
			# Disable the RX watermarks
			call system_endpoint_set_watermarks( 5, 0, $ff )
		end if
	end if
end

# Executed when there is data available from UART
event system_endpoint_watermark_rx( endpoint, size )
    # If the endpoint is the UART endpoint
	if endpoint = 5
		# Set the length of the input data
        in_len = size

		# Since we can only hvae 20 bytes of data, check this
		if in_len > 20 then 
            # If too much data, set the length to the max amount
            in_len = 20
		end if 

        # Disable RX watermark
        call system_endpoint_set_watermarks( 5, 0, $ff )

		# Get the data from the UART
		call system_endpoint_rx( 5, in_len )( result, in_len, in( 0 : in_len ) )

		# Write the result to the device on the other side of the bluetooth
		# connection, if there is an established connection with the telit
		if connected = 1 
		    call attributes_write( xgatt_data, 0, in_len, in( 0 : in_len ) )
        end if
	end if
end

# Executed when the remote device acknowledges data reception
event attclient_indicated( connection, attrhandle )
	if attrhandle = xgatt_data then 
		# Enable the RX watermark for 1 byte so that 
		# more data can be received over UART
		call system_endpoint_set_watermarks( 5, 1, $ff )
		
		# Reset the amount of data that was received from UART
		in_len = 0
	end if
end
